<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>链式调用和值的穿透</title>
</head>

<body>

</body>
<script>
    /**
     * promise的优势就是链式调用。使用promise，当then函数中return了一个值，不管是什么值，都能在下一个then中获取到，这就是链式调用
     * 当我们不在 then 中放入参数，例：promise.then().then()，那么其后面的 then 依旧可以得到之前 then 返回的值，这就是所谓的值的穿透
     * 
     * 那思路就是：没次调用then的时候，都创建一个promise，并且把上一个then返回的结果，传递给新的promise的then，然后一直then下去
     * 
     * 结合 Promise/A+ 规范梳理一下思路
     * 1. then的参数onFulfilled 和onRejected 可以省略，如果onFulfilled，onRejected不是函数，将其忽略，
     * 且依旧可以在then中获取到之前返回的值
     * 2. promise可以then多次，没次执行完promise.then都会返回一个新的promise(因为pormise的状态一旦改变，就不会发生变化，所以需要返回一个新的promise)
     * 3. 如果then的返回值，是一个普通值，那么会把这个结果作为参数，传递给下一个then的成功的回调函数中
     * 4. 如果then的返回值，抛出异常，那么会把这个异常作为参数，传递给then失败的回调zhong
     * 5. 如果then的返回值是一个promise，那么会等这个promise执行完，promise如果成功，就走下一个then 的成功，
     * 如果失败，就走下一个then的失败，如果抛异常，就走下一个then的失败
     * 6. 如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 
     * 的失败的回调中；
     * 7. 如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略 
     * 
    */
    const Pending = 'Pending'
    const Fulfilled = 'Fulfilled'
    const Rejected = 'Rejected'
    // 实现对参数x的多种可能性判断
    const resolvePromise = (promise2, x, resolve, reject) => {
        // 若 x 和 promise2 引用的是同一个对象，则直接报错
        if (x === promise2) {
            reject(new TypeError(`TypeError: Chaining cycle detected for promise #<Promise>`))
        }
        // 如果x是对象或者函数，判断有没有then 方法，当存在then方法，此时就表明x是一个promise，那么执行then方法
        if ((typeof x === 'object' && x != null) || typeof x === 'function') {
            let called = false// then 的回调函数只能执行一次，要么成功，要么失败(设置标识符 called)

            try {
                // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
                let then = x.then;
                if (typeof then === 'function') {
                    // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
                    then.call(x, y => { // 根据 promise 的状态决定是成功还是失败
                        if (called) return;
                        called = true;
                        // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
                        resolvePromise(promise2, y, resolve, reject);
                    }, r => {
                        // 只要失败就失败 Promise/A+ 2.3.3.3.2
                        if (called) return;
                        called = true;
                        reject(r);
                    });
                } else {
                    // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
                    resolve(x);
                }
            } catch (e) {
                // Promise/A+ 2.3.3.2
                if (called) return;
                called = true;
                reject(e)
            }
        } else {
            // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
            resolve(x)
        }


    }
    class _Promise {
        constructor(executor) {
            this.state = Pending
            this.value = undefined
            this.reason = undefined
            this.onFulfilledCallbacks = []
            this.onRejectedCallbacks = []
            let resolve = (value) => {
                if (this.state === Pending) {
                    this.state = Fulfilled
                    this.value = value
                    // 依次将对应的函数执行
                    this.onFulfilledCallbacks.forEach(fn => fn())
                }

            }
            let reject = (reason) => {
                if (this.state === Pending) {
                    this.state = Rejected
                    this.value = reason
                    // 依次将对应的函数执行
                    this.onRejectedCallbacks.forEach(fn => fn())

                }
            }
            try {
                executor(resolve, reject)
            } catch (error) {
                reject(error)

            }
        }
        then(onFulfilled, onRejected) {
            //解决 onFufilled，onRejected 没有传值的问题
            onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
            //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
            onRejected = typeof onRejected === 'function' ? onRejected : e => { throw e }
            // 每次调用 then 都返回一个新的 promise 
            let promise2 = new _Promise((resolve, reject) => {
                if (this.state === Fulfilled) {
                    setTimeout(() => {
                        try {
                            let x = onFulfilled(this.value)
                            // x可能是一个promise
                            resolvePromise(promise2, x, resolve, reject);

                        } catch (error) {
                            reject(error)
                        }
                    })
                }
                if (this.state === Rejected) {
                    setTimeout(() => {
                        try {
                            let x = onRejected(this.reason)
                            resolvePromise(promise2, x, resolve, reject);
                        } catch (error) {
                            reject(error)
                        }


                    })
                }
                // 如果状态是pending，依次将成功和失败的回调保存起来，
                if (this.state === Pending) {
                    this.onFulfilledCallbacks.push(() => {
                        setTimeout(() => {
                            try {
                                let x = onFulfilled(this.value)
                                resolvePromise(promise2, x, resolve, reject);

                            } catch (error) {
                                reject(error)
                            }
                        })

                    })
                    this.onRejectedCallbacks.push(() => {
                        setTimeout(() => {
                            try {
                                let x = onRejected(this.reason)
                                resolvePromise(promise2, x, resolve, reject);
                            } catch (error) {
                                reject(error)
                            }
                        })
                    })
                    //在 then 方法中，并没有往队列中直接插入回调函数, 而是使用函数包装后再 push，是为了方便后续扩展 
                    // ( eg：获取并处理 onFulfilled() 的返回值)
                }
            })
            return promise2
        }
    }
    // 上面都有一个共同的
    // setTimeout (()=>{
    //     try {
    //          let x = xxx
    //         resolvePromise(promise2, x, resolve, reject);

    //     } catch (error) {
    //         reject()
    //     }
    // })
    // 因为new Promise还没有结束，就去访问promsie2,肯定会报错，所以加一个定时器，起到延迟访问的作用
    // x代表了回调函数的返回值(需要判断他的多种情况)，需要promise2的resolve, reject 传递 x，所以这几个参数是必不可少的

    // 测试
    const promise = new Promise((resolve, reject) => {
        resolve('成功');
    }).then().then().then(data => {
        console.log(data); // 成功
    }, err => {
        console.log('err', err);
    })

// promise的API实现 16.3.html
</script>

</html>