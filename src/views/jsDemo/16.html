<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    //    版本一
    // promsie实现，简单版: 结合 Promise/A+ 规范，我们可以分析出 Promise 的基本特征：
    /**
     * 1. promise有三个状态，pending,fulfilled, rejected
     * 2. new promise的时候，需要传入一个executor() 执行器，执行器立即执行
     * 3. executor接收两个参数，分别是resolve,reject
     * 4. promise 的默认状态是pending
     * 5. promise有个value保存成功状态的值，可以是undefined/thenable/promise
     * 6. promise有个resson保存失败状态的值
     * 7.promise只能从pending到resolve，或者pending到fulfilled。状态一旦改变，就不会再次改变
     * 8. promise必须有一个then方法，then接收两个参数，分别是promise成功的回调函数onFulfilled,和promise失败的回调函数onReject
     * 9. 如果调用then时，promise已经成功，则执行onFulfilled,参数是promise的value
     * 10. 如果调用then时，promise已经失败，则执行onRejected,参数是promise的reason
     * 11. 如果then中抛出了异常，那么会把这个异常作为参数，传递给下一个then的失败的回调onRejected
     *
    */
    //    代码实现
    //    三个状态 Pending, Fulfilled, Rejected
    const Pending = 'Pending'
    const Fulfilled = 'Fulfilled'
    const Rejected = 'Rejected'
    class _Promise {
        constructor(executor) {
            // 默认状态是pending
            this.state = Pending
            // 存放成功状态的值，默认是undefined
            this.value = undefined
            // 存放失败状态的值。默认是undefined
            this.reason = undefined
            // 调用此方法就是成功
            let resolve = (value) => {
                // 状态为pending才可以更新状态，以免executor调用两次resolve/ reject
                if (this.state === Pending) {
                    this.state = Fulfilled
                    this.value = value
                }
            }
            let reject = (reason) => {
                if (this.state === Pending) {
                    this.state = Rejected
                    this.reason = reason
                }
            }
            try {
                // 立即执行，将reaolve,reject 传递给使用者
                executor(resolve, reject)
            } catch (error) {
                reject(error)
            }
        }
        // 包含一个then方法，并且接收两个参数 onFulfilled, onRejected
        then(onFulfilled, onRejected) {
            if (this.state === Fulfilled) {
                onFulfilled(this.value)
            }
            if (this.state === Rejected) {
                onRejected(this.reason)
            }
        }

    }

    // 调用
    const promise = new _Promise((resolve, reject) => {
        resolve('success')
        reject('error')
    }).then((res) => {
        console.log('成功', res)
    }, (err) => {
        console.log('失败', err)

    })

    // 输出 成功， success 。因为一旦状态改变，就不会再变。实现了一个基本的promise
    // 那如果出现异步的情况，该输出什么呢

    const promise2 = new _Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('success')
        })
    }).then((res) => {
        console.log('成功', res)
    })
    // 这个目前是不会输出的，因为promise调用then时，当前的promise并没有成功，一直是pending状态。
    // 那怎么解决呢? 
    // 当前如果状态是pending，就先将成功和失败的回调保存起来，
    // 在executor异步执行任务时，触发,resolve,reject。依次调用成功和失败的回调 = >  发布订阅者模式，收集依赖，触发通知，取出依赖执行
    // 详细见 16.1.html
</script>

</html>