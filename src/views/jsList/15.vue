<template>
  <div>
    <h1>15. 事件循环机制</h1>
    <pre>
        js是单线程
    </pre>
    <pre>
       基本概念 ：
       1. 一开始整个脚本作为宏任务执行
       2. 执行的过程中遇到同步任务直接执行，宏任务进入宏任务队列，微任务进入微任务队列
       3.  当前宏任务执行完，出队。检查微任务队列，有则一次执行，直到全部执行完毕
       4. 执行浏览器的渲染工作
       5. 检查是否有web worker 有则执行
       6. 执行完本轮的宏任务，回到2.依次循环，知道宏任务和微任务为空
    </pre>

    <pre>
       全面理解
       

       js是一门单线程语言，如果是多线程，浏览器就不知道以那个操作为准。但是浏览器内核是多线程(1)的，在浏览器内核中不同的异步操作，
       由浏览器不同的浏览器内核模块调度执行，浏览器内核包含三种webAPI dom绑定,网络请求，定时器模块

       首先判断js代码是同步还是异步，不停的检查调用栈中是否有任务要执行。
       如果没有，就检查任务队列，从中弹出一个任务，放入栈中，如此循环往复。要是同步，就进入主线程，异步就注册事件表

       异步任务在事件表中注册函数，当满足条件后，被推入事件队列

        同步任务进入主线程后一直执行，知道主线程空闲时，才会去事件队列看是否有可执行的异步任务，如果有，就推入主线程

        这就是事件循环，他是链接任务队列和控制调用栈的

    </pre>

    <pre>
        为什么要引入微任务?
         宏任务先进先出，微任务就是起到一个插队，可以提高优先级
    </pre>

    <pre>
        await: 把它描述的函数，放到new promise 里，把它后面的，放到then里面
    </pre>

    <pre>
        macro-task(宏任务)：包括整体代码script，setTimeout，setInterval,网络请求
        micro-task(微任务)：Promise，process.nextTick
    </pre>

    <pre>
        (1):浏览器内核是多线程
                GUI渲染线程： 负责页面的渲染，解析 HTML，CSS 构成 DOM 树等。与js引擎互斥
                JS引擎线程：单线程工作，负责解析运行js脚本
                事件触发线程: 当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。
                定时器触发线程: 浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。
                             开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。


                异步http请求线程: http 请求的时候会开启一条请求线程。
                                请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。

        

    </pre>
    <pre style="color: green; font-size: 20px">
        详细见 jsList/15.vue
    </pre>
  </div>
</template>

<script>
export default {};
</script>

<style lang="scss" scoped>
</style>